// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum QuestionType {
  MCQ4
  TRUE_FALSE
  SHORT_ANSWER
}
enum Difficulty {
  NHAN_BIET
  THONG_HIEU
  VAN_DUNG
}
enum NodeType {
  DOMAIN
  TOPIC
  SUBTOPIC
  OUTCOME
}
enum QuestionStatus {
  DRAFT
  REVIEWED
  PUBLISHED
  ARCHIVED
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questions      Question[]       @relation("Author")
  questionEdits  QuestionRevision[]
  attempts       Attempt[]
}

model TaxonomyNode {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  type        NodeType
  parentId    String?
  parent      TaxonomyNode? @relation("TaxonomyHierarchy", fields: [parentId], references: [id])
  children    TaxonomyNode[] @relation("TaxonomyHierarchy")

  questions QuestionTag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([parentId])
}

model Question {
  id            String         @id @default(cuid())
  stem          String
  type          QuestionType
  difficulty    Difficulty
  status        QuestionStatus @default(DRAFT)
  explanation   String?
  source        String?
  timeLimitSec  Int?
  metadata      Json?

  options   QuestionOption[]
  answers   ShortAnswer[]
  tags      QuestionTag[]
  assets    QuestionAsset[]
  examQuestions ExamQuestion[]
  responses     Response[]

  createdById String?
  createdBy   User?            @relation("Author", fields: [createdById], references: [id])

  revisions QuestionRevision[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, difficulty, status])
}

model QuestionOption {
  id         String   @id @default(cuid())
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  label      String?
  content    String
  isCorrect  Boolean  @default(false)
  order      Int
  feedback   String?
  @@index([questionId])
}

model ShortAnswer {
  id         String   @id @default(cuid())
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  text       String?
  regex      String?
  score      Float?
}

model QuestionTag {
  questionId     String
  taxonomyNodeId String
  question       Question     @relation(fields: [questionId], references: [id], onDelete: Cascade)
  node           TaxonomyNode @relation(fields: [taxonomyNodeId], references: [id], onDelete: Cascade)
  @@id([questionId, taxonomyNodeId])
  @@index([taxonomyNodeId])
}

model Asset {
  id        String   @id @default(cuid())
  url       String
  mime      String?
  width     Int?
  height    Int?
  alt       String?
  createdAt DateTime @default(now())
  questionLinks QuestionAsset[]
}

model QuestionAsset {
  questionId String
  assetId    String
  caption    String?
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  asset      Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  @@id([questionId, assetId])
}

model QuestionRevision {
  id         String   @id @default(cuid())
  questionId String
  version    Int
  snapshot   Json
  editorId   String?
  editor     User?    @relation(fields: [editorId], references: [id])
  createdAt  DateTime @default(now())
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  @@unique([questionId, version])
}

model Exam {
  id               String    @id @default(cuid())
  title            String
  grade            Int
  durationMinutes  Int
  shuffleQuestions Boolean  @default(true)
  publishedAt      DateTime?
  sections         ExamSection[]
  questions        ExamQuestion[]
  attempts         Attempt[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ExamSection {
  id       String  @id @default(cuid())
  examId   String
  exam     Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  title    String
  order    Int
  targetNb Int?
  targetTh Int?
  targetVd Int?
}

model ExamQuestion {
  examId       String
  questionId   String
  order        Int
  points       Float   @default(1.0)
  shuffleGroup Int?
  exam         Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  question     Question @relation(fields: [questionId], references: [id], onDelete: Restrict)
  @@id([examId, questionId])
  @@index([questionId])
}

model Attempt {
  id         String   @id @default(cuid())
  examId     String
  userId     String?
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  score      Float?
  exam       Exam  @relation(fields: [examId], references: [id], onDelete: Cascade)
  user       User? @relation(fields: [userId], references: [id])
  answers    Response[]
  @@index([examId])
}

model Response {
  id         String   @id @default(cuid())
  attemptId  String
  questionId String
  answer     Json
  isCorrect  Boolean?
  score      Float?
  answeredAt DateTime @default(now())
  attempt    Attempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Restrict)
  @@index([attemptId])
  @@index([questionId])
}
